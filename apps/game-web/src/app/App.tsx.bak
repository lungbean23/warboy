// apps/game-web/src/app/App.tsx

// ──────────────────────────────────────────────────────────────────────────────
// UI SYSTEM (canvas HUD + input)
// Good module seam: keep UI primitives (manager, widgets, panels) in /ui/*
// ──────────────────────────────────────────────────────────────────────────────
import { UIManager } from './ui/manager';
import { ChatHud } from './ui/chat/chatHUD';
import { createTextCapture } from './ui/input/textCapture';
import { wireChat } from './chat/wireChat';

// ──────────────────────────────────────────────────────────────────────────────
// REACT + GAME BOOTSTRAP
// ──────────────────────────────────────────────────────────────────────────────
import React, { useEffect, useRef, useState } from 'react';

// ──────────────────────────────────────────────────────────────────────────────
// NETWORKING (WS client + message types)
// Good module seam: /game/net/*
// ──────────────────────────────────────────────────────────────────────────────
import { connectWS } from './game/net/wsClient';

// ──────────────────────────────────────────────────────────────────────────────
// WORLD DATA / CACHING / COORD MATH
// Good module seam: /game/world/* & @warboy/world
// ──────────────────────────────────────────────────────────────────────────────
import { ChunkCache } from './game/world/cache';
import { CHUNK_SIZE, worldToChunk, localInChunk, edgePrefetch, directionalAOI, aoiRect } from '@warboy/world';





// ──────────────────────────────────────────────────────────────────────────────
// SPRITES / ANIMATION
// Good module seam: /game/sprites/*
// ──────────────────────────────────────────────────────────────────────────────
import heroUrl from './game/assets/sprites/Alex_16x16.png';
import { loadImage } from './game/sprites/loader';
import { SpriteSheet } from './game/sprites/spriteSheet';
import { Animator } from './game/sprites/anim';

// shared, long‑lived chunk cache
const cache = new ChunkCache();

export function App() {
  const [status, setStatus] = useState('disconnected');
  const [id, setId] = useState<string | null>(null);
  const [players, setPlayers] = useState<any[]>([]);

  // canvas / draw loop refs
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const ctxRef = useRef<CanvasRenderingContext2D | null>(null);
  const rafRef = useRef<number | null>(null);

  // network + game state refs
  const playersRef = useRef<any[]>([]);
  const idRef = useRef<string | null>(null);
  const wsRef = useRef<any>(null);
  const lastPosRef = useRef<{ tx: number; ty: number } | null>(null);

  // sprite state
  const heroSheetRef = useRef<SpriteSheet | null>(null);
  const heroAnimRef = useRef<Animator | null>(null);
  const heroRowRef = useRef(0);
  const lastDrawPosRef = useRef<{ tx: number; ty: number } | null>(null);

  // ui system
  const uiRef = useRef<UIManager | null>(null);
  const chatRef = useRef<ChatHud | null>(null);

  useEffect(() => { playersRef.current = players; }, [players]);
  useEffect(() => { idRef.current = id; }, [id]);

  // ────────────────────────────────────────────────────────────────────────────
  // ASSET PRELOAD (sprite sheet)
  // ────────────────────────────────────────────────────────────────────────────
  useEffect(() => {
    let alive = true;
    (async () => {
      const img = await loadImage(heroUrl);
      if (!alive) return;
      const cols = Math.floor(img.width / 16);
      heroSheetRef.current = new SpriteSheet(img, 16, 16, cols);
      heroAnimRef.current = new Animator({ frames: [0, 1, 2, 3], fps: 8, loop: true });
    })();
    return () => { alive = false; };
  }, []);

  // ────────────────────────────────────────────────────────────────────────────
  // NETWORK CONNECT (WS) — module seam: isolate in /game/net
  // ────────────────────────────────────────────────────────────────────────────
  useEffect(() => {
    setStatus('connecting');
    const name = `warboy-${Math.floor(Math.random() * 1000)}`;
    const url = import.meta.env?.VITE_WS_URL || `ws://${location.hostname}:8787`;

    const ws = connectWS({
      url,
      name,

      onChat: (m) => {
        chatRef.current?.addLine(`${m.from?.name ?? m.from?.id ?? 'anon'}: ${m.text}`);
      },

      onWelcome: (me) => {
        setId(me.id);
        setStatus('connected');
        chatRef.current?.addLine(`system: connected as ${me.id}`);

        const { cx, cy } = worldToChunk(0, 0, CHUNK_SIZE);

        // request a 3x3 AOI initially
        const req3x3 = () => {
          for (const { cx: x, cy: y } of aoiRect(cx, cy, 1, 1)) {
            ws.chunkReq?.(x, y);
          }
        };
        req3x3();

        // re-request center ring until at least center is cached
        let tries = 0;
        const iv = setInterval(() => {
          if (cache.has(cx, cy) || tries++ > 10) return clearInterval(iv);
          console.log('[retry] requesting chunks...');
          req3x3();
        }, 1000);
      },

      onSnapshot: (snap) => {
        // debug/telemetry: consider module seam in /telemetry
        console.log('[snapshot]', snap.players.map((p: any) => ({
          id: p.id, name: p.name, tx: p.tx, ty: p.ty, x: p.x, y: p.y
        })));
        setPlayers(snap.players);
      },

      onChunk: (msg) => {
        // WORLD MERGE / PATCH APPLY — keep this logic in /game/world
        console.log('[onChunk]', msg);
        if (msg?.t === 'chunkData') {
          cache.setFromSnap(msg);
        }
      },

      onClose: () => {
        setStatus('disconnected');
        chatRef.current?.addLine('system: disconnected');
      },
    });

    wsRef.current = ws;

    // NOTE: movement keys are handled here; UI keys go through UIManager below
   const onKeyDown = (e: KeyboardEvent) => {
   const uiHandled = uiRef.current?.handleKeyDown(e) ?? false;
   if (uiHandled) {
     e.preventDefault();
     return;
   }

   const k = e.key.toLowerCase();
   const dx = k === 'arrowright' || k === 'd' ? 1 : k === 'arrowleft' || k === 'a' ? -1 : 0;
   const dy = k === 'arrowdown' || k === 's' ? 1 : k === 'arrowup' || k === 'w' ? -1 : 0;

   if (dx || dy) {
     e.preventDefault();
     wsRef.current?.intent(dx, dy);
   }
   }; 
   window.addEventListener('keydown', onKeyDown);

   return () => {
     window.removeEventListener('keydown', onKeyDown);
     try { ws.close(); } catch {}
     wsRef.current = null;
   };
  }, []);

  // ────────────────────────────────────────────────────────────────────────────
  // AOI / PREFETCH SYSTEM — module seam: /game/systems/aoiPrefetch
  // ────────────────────────────────────────────────────────────────────────────
  useEffect(() => {
    let lastCenter: { cx: number; cy: number } | null = null;

    const tick = () => {
      const me = playersRef.current.find((p) => p.id === idRef.current);
      if (!me) return;

      const tx = me.tx ?? 0;
      const ty = me.ty ?? 0;
      const prev = lastPosRef.current;
      const dx = prev ? Math.sign(tx - prev.tx) : 0;
      const dy = prev ? Math.sign(ty - prev.ty) : 0;
      lastPosRef.current = { tx, ty };

      const { cx, cy } = worldToChunk(tx, ty, CHUNK_SIZE);
      const { lx, ly } = localInChunk(tx, ty, CHUNK_SIZE);

      let recompute = false;
      if (!lastCenter || cx !== lastCenter.cx || cy !== lastCenter.cy) {
        lastCenter = { cx, cy };
        recompute = true;
      } else {
        const near = edgePrefetch(lx, ly, dx, dy, 4, CHUNK_SIZE);
        recompute = near.west || near.east || near.north || near.south;
      }
      if (!recompute) return;

      const near = edgePrefetch(lx, ly, dx, dy, 4, CHUNK_SIZE);
      const needed = directionalAOI(cx, cy, near, 1);
      for (const { cx: x, cy: y } of needed) {
        if (!cache.has(x, y)) wsRef.current?.chunkReq?.(x, y);
      }
    };

    const handle = setInterval(tick, 150);
    return () => clearInterval(handle);
  }, []);

  // ────────────────────────────────────────────────────────────────────────────
  // CANVAS + RENDER LOOP — module seam: /game/render/*
  // split world render vs. UI overlay draw
  // ────────────────────────────────────────────────────────────────────────────
  useEffect(() => {
    const c = canvasRef.current;
    if (!c) return;
    const ctx = c.getContext('2d');
    if (!ctx) return;
    ctxRef.current = ctx;

    // --- UI setup ---
    // Good module seam: /ui (manager, panels)
    const ui = new UIManager();
    uiRef.current = ui;

 

    const chat = new ChatHud(
      { x: 8, y: 8, w: Math.min(360, (c.clientWidth || 800) * 0.4), h: 180 },
      (text) => wsRef.current?.chat?.(text)
    );
    chatRef.current = chat;
    ui.add(chat);

    // --- input plumbing (pointer + wheel go to UI first) ---
    const toPoint = (e: PointerEvent | MouseEvent, target: HTMLCanvasElement) => {
      const rect = target.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    };

    const onPointerDown = (e: PointerEvent) => {
      const p = toPoint(e, c);
      ui.dispatch({ t: 'pointerDown', p, id: e.pointerId });
    };
    const onPointerMove = (e: PointerEvent) => {
      const p = toPoint(e, c);
      ui.dispatch({ t: 'pointerMove', p, id: e.pointerId });
    };
    const onPointerUp = (e: PointerEvent) => {
      const p = toPoint(e, c);
      ui.dispatch({ t: 'pointerUp', p, id: e.pointerId });
    };

    // non‑passive so preventDefault() works when UI consumes the scroll
    const onWheel = (e: WheelEvent) => {
      const handled = ui.dispatch({ t: 'wheel', dx: e.deltaX, dy: e.deltaY });
      if (handled) e.preventDefault();
    };

    // Route keyboard through UI manager fallback (printables/Enter/Backspace/IME)
    const onKeyDown = (e: KeyboardEvent) => {
      const handled = ui.handleKeyDown(e);
      if (handled) e.preventDefault();
    };

    c.addEventListener('pointerdown', onPointerDown);
    c.addEventListener('pointermove', onPointerMove);
    c.addEventListener('pointerup', onPointerUp);
    c.addEventListener('wheel', onWheel, { passive: false });
    window.addEventListener('keydown', onKeyDown);

    // size / DPR
    const resize = () => {
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      const cssW = c.clientWidth || 800;
      const cssH = c.clientHeight || 450;
      c.width = Math.max(1, Math.floor(cssW * dpr));
      c.height = Math.max(1, Math.floor(cssH * dpr));
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };
    resize();
    window.addEventListener('resize', resize);

    // render loop
    const draw = () => {
      const ctx2 = ctxRef.current;
      if (!ctx2) return;

      const cssW = c.clientWidth || 800;
      const cssH = c.clientHeight || 450;

      // clear & bg
      ctx2.clearRect(0, 0, cssW, cssH);
      ctx2.fillStyle = '#101010';
      ctx2.fillRect(0, 0, cssW, cssH);

      // WORLD RENDER — module seam: put into /game/render/world
      const curPlayers = playersRef.current;
      const meId = idRef.current;
      const me = curPlayers.find((p) => p.id === meId);
      const tx = me?.tx ?? 0;
      const ty = me?.ty ?? 0;
      const TILE_PIX = 8;
      const tileColor: Record<number, string> = {
        0: '#2050ff', // water
        1: '#2aa745', // grass
        2: '#999999', // rock
      };

      // draw chunks around player
      const center = worldToChunk(tx, ty, CHUNK_SIZE);
      for (let gy = -1; gy <= 1; gy++) {
        for (let gx = -1; gx <= 1; gx++) {
          const ccx = center.cx + gx;
          const ccy = center.cy + gy;
          const ch = cache.get?.(ccx, ccy) ?? cache.getChunk?.(ccx, ccy);
          if (!ch) continue;
          const w = ch.w ?? ch.width ?? CHUNK_SIZE;
          const h = ch.h ?? ch.height ?? CHUNK_SIZE;
          const tiles = (ch.tiles ?? ch.tilesU8);
          if (!tiles) continue;

          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const t = tiles[y * w + x] | 0;
              ctx2.fillStyle = tileColor[t] ?? '#444';
              const wx = ccx * CHUNK_SIZE + x;
              const wy = ccy * CHUNK_SIZE + y;
              const sx = Math.floor(cssW / 2 + (wx - tx) * TILE_PIX);
              const sy = Math.floor(cssH / 2 + (wy - ty) * TILE_PIX);
              ctx2.fillRect(sx, sy, TILE_PIX, TILE_PIX);
            }
          }
          // optional chunk border (debug)
          ctx2.strokeStyle = '#222';
          const topLeftX = Math.floor(cssW / 2 + (ccx * CHUNK_SIZE - tx) * TILE_PIX);
          const topLeftY = Math.floor(cssH / 2 + (ccy * CHUNK_SIZE - ty) * TILE_PIX);
          ctx2.strokeRect(topLeftX, topLeftY, CHUNK_SIZE * TILE_PIX, CHUNK_SIZE * TILE_PIX);
        }
      }

      // OTHER PLAYERS — could be a separate layer/system
      const others = curPlayers.filter((p) => p.id !== meId);
      for (const p of others) {
        const ox = p.tx ?? 0;
        const oy = p.ty ?? 0;
        const sx = Math.floor(cssW / 2 + (ox - tx) * TILE_PIX);
        const sy = Math.floor(cssH / 2 + (oy - ty) * TILE_PIX);
        ctx2.fillStyle = '#ffd400';
        ctx2.fillRect(sx - 3, sy - 6, 6, 6);
        ctx2.strokeStyle = '#000';
        ctx2.strokeRect(sx - 3, sy - 6, 6, 6);
        ctx2.fillStyle = '#ffffff';
        ctx2.font = '10px system-ui';
        ctx2.textAlign = 'center';
        ctx2.fillText(p.name ?? p.id.slice(0, 4), sx, sy - 8);

        // UI ghost (minimap-ish)
        const sxUI = (p.x / 100) * cssW;
        const syUI = (p.y / 100) * cssH;
        ctx2.fillStyle = '#ff00ff';
        ctx2.fillRect(sxUI - 2, syUI - 2, 4, 4);
      }

      // DEBUG HUD — could move to /ui/panels/debugHud
      ctx2.fillStyle = '#fff';
      ctx2.font = '12px monospace';
      ctx2.textAlign = 'left';
      ctx2.fillText(`players:${curPlayers.length} me:${meId?.slice(0, 4) ?? '—'} tx:${tx} ty:${ty}`, 8, 16);

      // HERO SPRITE — module seam: /game/render/hero
      const sheet = heroSheetRef.current;
      const anim = heroAnimRef.current;
      if (sheet && anim) {
        const prev = lastDrawPosRef.current;
        const dx = prev ? Math.sign(tx - prev.tx) : 0;
        const dy = prev ? Math.sign(ty - prev.ty) : 0;
        lastDrawPosRef.current = { tx, ty };
        let row = heroRowRef.current;
        if (Math.abs(dx) > Math.abs(dy)) row = dx > 0 ? 1 : 3; // right/left
        else if (Math.abs(dy) > 0) row = dy < 0 ? 2 : 0; // up/down
        if (row !== heroRowRef.current) {
          heroRowRef.current = row;
          const base = row * sheet.columns;
          anim.set({ frames: [base + 0, base + 1, base + 2, base + 3], fps: 8, loop: true });
        }
        const scale = 8 / 16;
        const frame = anim.frameIndex();
        const drawX = Math.floor(cssW / 2 - (16 * scale) / 2);
        const drawY = Math.floor(cssH / 2 - (16 * scale) + 2);
        sheet.drawFrame(ctx2, frame, drawX, drawY, scale);
      }

      // UI OVERLAY — all canvas widgets (chat, etc)
      uiRef.current?.draw(ctx2);

      rafRef.current = requestAnimationFrame(draw);
    };

    rafRef.current = requestAnimationFrame(draw);

    // cleanup
    return () => {
      window.removeEventListener('resize', resize);
      if (rafRef.current != null) cancelAnimationFrame(rafRef.current);

      c.removeEventListener('pointerdown', onPointerDown);
      c.removeEventListener('pointermove', onPointerMove);
      c.removeEventListener('pointerup', onPointerUp);
      c.removeEventListener('wheel', onWheel);
      window.removeEventListener('keydown', onKeyDown);

      uiRef.current?.destroy();
      uiRef.current = null;
      chatRef.current = null;

      rafRef.current = null;
      ctxRef.current = null;
    };
  }, []);

  return (
    <div style={{ color: '#ddd', fontFamily: 'system-ui', padding: 8 }}>
      <div>status: {status} {id ? `| id: ${id}` : ''}</div>

      {/* Canvas host div — good mount point for hidden textCapture */}
      <div style={{ border: '1px solid #333', marginTop: 8, width: '100%', maxWidth: 960, aspectRatio: '16 / 9' }}>
        <canvas ref={canvasRef} style={{ width: '100%', height: '100%', display: 'block' }}/>
      </div>

      <div style={{ marginTop: 8 }}>WASD / Arrow keys move your square.</div>
    </div>
  );
}

export default App;

